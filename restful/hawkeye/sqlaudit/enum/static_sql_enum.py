# uncompyle6 version 3.2.3
# Python bytecode 3.6 (3379)
# Decompiled from: Python 2.7.5 (default, Jul 13 2018, 13:06:57) 
# [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)]
# Embedded file name: ./sqlaudit/enum/static_sql_enum.py
# Compiled at: 2018-08-23 19:33:14
# Size of source mod 2**32: 6881 bytes
StaticSQLJson = {'REDUNDANT_INDEX':{'sql':"\n    WITH\n         ind_cols AS (SELECT col.index_owner, col.index_name, col.table_owner, col.table_name, a.index_type, a.uniqueness,\n                             MAX(CASE col.column_position WHEN 01 THEN      col.column_name END)||\n                             MAX(CASE col.column_position WHEN 02 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 03 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 04 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 05 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 06 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 07 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 08 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 09 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 10 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 11 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 12 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 13 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 14 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 15 THEN ':'||col.column_name END)||\n                             MAX(CASE col.column_position WHEN 16 THEN ':'||col.column_name END) indexed_columns\n                        FROM dba_ind_columns col,\n                             dba_indexes a\n                       WHERE {table_pred}\n                         AND a.owner = col.index_owner\n                         AND a.index_name = col.index_name\n                       GROUP BY col.index_owner,col.index_name,col.table_owner,col.table_name,a.index_type,a.uniqueness)\n    SELECT r.table_owner, r.table_name, r.index_name\n              FROM ind_cols r\n             WHERE r.indexed_columns LIKE '{pred}'||':%%' or r.indexed_columns = '{pred}'", 
  'schema_name':'col.table_owner,col.table_name'}, 
 'BAD_PLAN':{'sql': "select\n                            ID,\n                            OPERATION || ' ' || OPTIONS OPERATION,\n                            OBJECT_OWNER,\n                            OBJECT_NAME,\n                            COST,\n                            CARDINALITY,\n                            ACCESS_PREDICATES,\n                            FILTER_PREDICATES\n                        from plan_table\n                        where {pred} order by id"}, 
 'TYPE_CONVERSION':{'sql': "select\n                            ID,\n                            OPERATION || ' ' || OPTIONS OPERATION,\n                            OBJECT_OWNER,\n                            OBJECT_NAME,\n                            COST,\n                            CARDINALITY,\n                            ACCESS_PREDICATES,\n                            FILTER_PREDICATES\n                        from plan_table\n                        where {pred} order by id"}, 
 'OVER_BIND_VARIABLE':{'sql': "\nselect\n    dummy\nfrom dual\nwhere\nREGEXP_LIKE(:sql_text, ':[0-9A-Z][0-9A-Z]* *IS NULL', 'i')"}, 
 'UPDATE_WHERE':{'sql': "\nselect 'X' dummy\n    from plan_table\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'UPDATE STATEMENT'\n  connect by prior id = PARENT_ID"}, 
 'DELETE_WHERE':{'sql': "\nselect 'X' dummy\n    from plan_table\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'DELETE STATEMENT'\n  connect by prior id = PARENT_ID"}, 
 'SELECT_WHERE':{'sql': "\nselect 'X' dummy\n    from plan_table\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'DELETE STATEMENT'\n  connect by prior id = PARENT_ID"}, 
 'PLAN_FILTER':{'sql': "\nselect\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom plan_table\nwhere operation = 'FILTER'"}, 
 'PARALLEL_PLAN':{'sql': "\nselect\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom plan_table\nwhere operation = 'PX COORDINATOR'"}, 
 'NESTED_BLOCK':{'sql': '\n        select \'X\' dummy\n        from\n                plan_table p\n        where\n        p.other_xml is not null\n        and (SELECT /*+ opt_param(\'parallel_execution_enabled\', \'false\') */\n                      count(*)\n                      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), \'/*/outline_data/hint\'))) d\n                      where regexp_like(extractvalue(value(d), \'/hint\'), \'^OUTLINE\\(@"SEL\\$[[:digit:]]"\\)\')\n              ) > {pred}'}, 
 'MANY_TABLE':{'sql': "\n        select 'X' dummy\n        from\n                plan_table p\n        where\n        p.other_xml is not null\n        and (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */\n                count(*)\n                FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), '/*/outline_data/hint'))) d\n                where regexp_like(extractvalue(value(d), '/hint'), '^(FULL|INDEX)')) > {pred}"}, 
 'FOR_UPDATE':{'sql': "\nselect\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom plan_table\nwhere operation = 'FOR UPDATE'"}, 
 'plans':{'sql': "\n            select\n                lpad(case when access_predicates is not null or filter_predicates is not null then '*' else '' end || id, 5, ' ') ID,\n                lpad(' ',depth*2,' ')||operation || ' ' || options PLAN_STEP,\n                OBJECT_NAME,\n                OBJECT_TYPE,\n                OBJECT_OWNER,\n                cardinality,\n                cost        COST,\n                substr(access_predicates,1,3989) access_predicates,\n                substr(filter_predicates,1,3989) filter_predicates\n            from\n                plan_table"}}
# okay decompiling ./restful/hawkeye/sqlaudit/enum/static_sql_enum.pyc

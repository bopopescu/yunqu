# uncompyle6 version 3.2.3
# Python bytecode 3.6 (3379)
# Decompiled from: Python 2.7.5 (default, Jul 13 2018, 13:06:57) 
# [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)]
# Embedded file name: ./sqlaudit/enum/oracle_single_sql_audit_enum.py
# Compiled at: 2018-08-23 19:33:14
# Size of source mod 2**32: 43505 bytes
OracleSingleTemplateJson = {'MULTI_PLAN':{'sql': '\n    WITH\n    p AS (\n    SELECT plan_hash_value\n      FROM gv$sql_plan\n     WHERE {inst_id_pred} and {sql_id_pred}\n       AND other_xml IS NOT NULL\n     UNION\n    SELECT plan_hash_value\n      FROM dba_hist_sql_plan\n     WHERE {sql_id_pred}\n       AND other_xml IS NOT NULL ),\n    m AS (\n    SELECT plan_hash_value,\n           SUM(elapsed_time)/SUM(executions) avg_et_secs\n      FROM gv$sql\n     WHERE {inst_id_pred} and {sql_id_pred}\n       AND executions > 0\n     GROUP BY\n           plan_hash_value ),\n    a AS (\n    SELECT plan_hash_value,\n           SUM(elapsed_time_total)/SUM(executions_total) avg_et_secs\n      FROM dba_hist_sqlstat\n     WHERE {sql_id_pred}\n       AND executions_total > 0\n     GROUP BY\n           plan_hash_value )\n    SELECT p.plan_hash_value PLAN_HASH_VALUE,\n           ROUND(NVL(m.avg_et_secs, a.avg_et_secs)/1e6, 3) AVG_ET_SECS\n      FROM p, m, a\n     WHERE p.plan_hash_value = m.plan_hash_value(+)\n       AND p.plan_hash_value = a.plan_hash_value(+)\n       AND (select count(*) from p) > 1\n     ORDER BY\n           avg_et_secs NULLS LAST'}, 
 'BAD_PLAN':{'sql': "select distinct\n                            PLAN_HASH_VALUE,\n                            ID,\n                            OPERATION || ' ' || OPTIONS OPERATION,\n                            OBJECT_OWNER,\n                            OBJECT_NAME,\n                            COST,\n                            CARDINALITY,\n                            ACCESS_PREDICATES,\n                            FILTER_PREDICATES\n                        from\n                            gv$sql_plan\n                where   {inst_id_pred} and {sql_id_pred} and {pred} order by id"}, 
 'TYPE_CONVERSION':{'sql': "select distinct\n                            PLAN_HASH_VALUE,\n                            ID,\n                            OPERATION || ' ' || OPTIONS OPERATION,\n                            OBJECT_OWNER,\n                            OBJECT_NAME,\n                            COST,\n                            CARDINALITY,\n                            ACCESS_PREDICATES,\n                            FILTER_PREDICATES\n                        from\n                            gv$sql_plan\n                where   {inst_id_pred} and {sql_id_pred} and {pred} order by id"}, 
 'CARDINALITY_GAP':{'sql': "select distinct\n                        SQL_PLAN_HASH_VALUE,\n                        PLAN_LINE_ID,\n                        PLAN_OPERATION || ' ' || PLAN_OPTIONS PLAN_OPERATION,\n                        PLAN_OBJECT_NAME OBJECT_NAME,\n                        PLAN_OBJECT_TYPE OBJECT_TYPE,\n                        PLAN_OBJECT_OWNER OBJECT_OWNER,\n                        PLAN_CARDINALITY,\n                        STARTS,\n                        OUTPUT_ROWS\n                  from (select\n                            SQL_PLAN_HASH_VALUE,\n                            PLAN_LINE_ID,\n                            PLAN_OPERATION,\n                            PLAN_OPTIONS,\n                            PLAN_OBJECT_NAME,\n                            PLAN_OBJECT_TYPE,\n                            PLAN_OBJECT_OWNER,\n                            PLAN_CARDINALITY,\n                            STARTS,\n                            OUTPUT_ROWS\n                    from\n                      (select /*+ leading(b a) use_hash(a)*/\n                            a.KEY,\n                            a.SQL_PLAN_HASH_VALUE,\n                            a.PLAN_LINE_ID,\n                            a.PLAN_OPERATION,\n                            a.PLAN_OPTIONS,\n                            a.PLAN_OBJECT_NAME,\n                            a.PLAN_OBJECT_TYPE,\n                            a.PLAN_OBJECT_OWNER,\n                            a.PLAN_CARDINALITY,\n                            a.STARTS,\n                            a.OUTPUT_ROWS,\n                            a.PLAN_PARENT_ID\n                         from gv$sql_plan_monitor a\n                            where a.{inst_id_pred} and a.{sql_id_pred}\n                            --and a.status like 'DONE%'\n                            )\n                        where connect_by_isleaf = 1\n                        start with PLAN_LINE_ID = 0\n                        connect by NOCYCLE prior PLAN_LINE_ID = PLAN_PARENT_ID and\n                                prior key = key\n                        ) where\n                        (starts = 1 or (PLAN_OPERATION = 'TABLE ACCESS' and PLAN_OPTIONS in ('FULL','STORAGE FULL','INMEMORY FULL')))\n                        and\n                        (PLAN_CARDINALITY/decode(OUTPUT_ROWS,0,1,OUTPUT_ROWS) > {pred} or OUTPUT_ROWS/PLAN_CARDINALITY > {pred})\n                        order by PLAN_LINE_ID"}, 
 'DATAFLOW_GAP':{'sql': "select distinct\n                        SQL_PLAN_HASH_VALUE,\n                        PLAN_LINE_ID,\n                        PLAN_OPERATION || ' ' || PLAN_OPTIONS PLAN_OPERATION,\n                        PLAN_OBJECT_NAME OBJECT_NAME,\n                        PLAN_OBJECT_TYPE OBJECT_TYPE,\n                        PLAN_OBJECT_OWNER OBJECT_OWNER,\n                        PLAN_CARDINALITY,\n                        STARTS,\n                        OUTPUT_ROWS,\n                        PARENT_PLAN_OPERATION,\n                        PARENT_PLAN_OPTIONS,\n                        PARENT_OUTPUT_ROWS,\n                        PLAN_PARENT_ID,\n                        PARENT_PLAN_OBJECT_TYPE,\n                        PARENT_PLAN_OBJECT_OWNER,\n                        PARENT_PLAN_OBJECT_NAME\n                    from\n                    (\n                    select\n                            SQL_PLAN_HASH_VALUE,\n                            PLAN_LINE_ID,\n                            PLAN_OPERATION,\n                            PLAN_OPTIONS,\n                            PLAN_OBJECT_NAME,\n                            PLAN_OBJECT_TYPE,\n                            PLAN_OBJECT_OWNER,\n                            PLAN_CARDINALITY,\n                            STARTS,\n                            OUTPUT_ROWS,\n                            prior PLAN_OPERATION PARENT_PLAN_OPERATION,\n                            prior PLAN_OPTIONS PARENT_PLAN_OPTIONS,\n                            prior OUTPUT_ROWS PARENT_OUTPUT_ROWS,\n                            PLAN_PARENT_ID PLAN_PARENT_ID,\n                            prior PLAN_OBJECT_TYPE PARENT_PLAN_OBJECT_TYPE,\n                            prior PLAN_OBJECT_OWNER PARENT_PLAN_OBJECT_OWNER,\n                            prior PLAN_OBJECT_NAME PARENT_PLAN_OBJECT_NAME\n                    from (select /*+ leading(b a) use_hash(a)*/\n                        a.KEY,\n                        a.SQL_PLAN_HASH_VALUE,\n                        a.PLAN_LINE_ID,\n                        a.PLAN_OPERATION,\n                        a.PLAN_OPTIONS,\n                        a.PLAN_OBJECT_NAME,\n                        a.PLAN_OBJECT_TYPE,\n                        a.PLAN_OBJECT_OWNER,\n                        a.PLAN_CARDINALITY,\n                        a.STARTS,\n                        a.OUTPUT_ROWS,\n                        a.PLAN_PARENT_ID\n                     from gv$sql_plan_monitor a\n                        where a.{inst_id_pred} and a.{sql_id_pred}\n                        --and a.status like 'DONE%'\n                        ) c\n                    where connect_by_isleaf = 1\n                    start with PLAN_LINE_ID = 0\n                    connect by NOCYCLE prior PLAN_LINE_ID = PLAN_PARENT_ID and\n                            prior key = key\n                    ) where\n                    (PARENT_PLAN_OPTIONS not in ('GROUP BY','UNIQUE','AGGREGATE','STOPKEY','ORDER BY STOPKEY') and PARENT_PLAN_OPERATION not like '%STATEMENT')\n                    and OUTPUT_ROWS/decode(PARENT_OUTPUT_ROWS,0,1,PARENT_OUTPUT_ROWS) > {pred}\n                    order by PLAN_LINE_ID"}, 
 'INDEX_ROWS':{'sql': "select distinct\n                SQL_PLAN_HASH_VALUE,\n                PLAN_LINE_ID,\n                PLAN_OPERATION || ' ' || PLAN_OPTIONS PLAN_OPERATION,\n                PLAN_OBJECT_NAME OBJECT_NAME,\n                PLAN_OBJECT_OWNER OBJECT_OWNER,\n                PLAN_CARDINALITY,\n                STARTS,\n                OUTPUT_ROWS\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {inst_id_pred} and {sql_id_pred}\n            and PLAN_OPERATION = 'INDEX'\n            and OUTPUT_ROWS/decode(STARTS,0,1,STARTS) > {pred}"}, 
 'OPERATION_STARTS':{'sql': "select distinct\n                SQL_PLAN_HASH_VALUE,\n                PLAN_LINE_ID,\n                PLAN_OPERATION || ' ' || PLAN_OPTIONS PLAN_OPERATION,\n                PLAN_OBJECT_NAME OBJECT_NAME,\n                PLAN_OBJECT_OWNER OBJECT_OWNER,\n                PLAN_CARDINALITY,\n                STARTS,\n                OUTPUT_ROWS\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {inst_id_pred} and {sql_id_pred}\n            and starts > {pred}"}, 
 'TABLE_OLD_STATS':{'sql':"\n        SELECT OWNER, TABLE_NAME, to_char(TRUNC(SYSDATE-last_analyzed)) MESSAGE\n          FROM dba_tables\n         WHERE {table_pred} and temporary = 'N' and last_analyzed < SYSDATE-{pred} order by 1,2,3", 
  'schema_name':'owner,table_name'}, 
 'TABLE_STALE_STATS':{'sql':"\n        SELECT owner, table_name,  '' MESSAGE\n          FROM dba_tab_statistics\n         WHERE stale_stats = 'YES' and {table_pred} and partition_name IS NULL and SUBPARTITION_NAME IS NULL\n      and (owner, TABLE_NAME ) not in (select owner, TABLE_NAME from dba_tables where {table_pred} and temporary = 'Y') order by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'TABLE_LOCKED_STATS':{'sql':"\n        SELECT owner, table_name,  '' MESSAGE\n          FROM dba_tab_statistics\n         WHERE stattype_locked IN ('ALL','DATA') and {table_pred} and partition_name IS NULL and SUBPARTITION_NAME IS NULL\n      and (owner, TABLE_NAME ) not in (select owner, TABLE_NAME from dba_tables where {table_pred} and temporary = 'Y') order by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'TABLE_MISSING_STATS':{'sql':"\n        SELECT a.owner, table_name, to_char(created,'yyyy-mm-dd') MESSAGE\n          FROM dba_tables a, dba_objects b\n         WHERE num_rows IS NULL and a.temporary = 'N' and {table_pred}\n         and (sysdate - created) > {pred}\n         and a.owner = b.owner\n         and a.TABLE_NAME = b.object_name\n          and b.object_type = 'TABLE' order by 1,2,3", 
  'schema_name':'a.owner, a.table_name'}, 
 'TABLE_INCONSISTENT_STATS':{'sql':"\n        SELECT owner, table_name,  to_char(blocks) MESSAGE\n          FROM dba_tables\n         WHERE num_rows = 0 and temporary = 'N' and blocks > {pred} and {table_pred} ", 
  'schema_name':'owner,table_name'}, 
 'TABLE_EMPTY_STATS':{'sql':"\n    SELECT owner, table_name,  '' MESSAGE\n      FROM dba_tables\n     WHERE num_rows = 0 and blocks = 0 and temporary = 'N' and {table_pred}  order by 1,2,3", 
  'schema_name':'owner,table_name'}, 
 'TABLE_PARTITIONS':{'sql':'\n        select\n            TABLE_OWNER owner, TABLE_NAME, to_char(count(*)) MESSAGE\n        from dba_tab_partitions a\n        where {table_pred}\n        group by TABLE_OWNER, table_name\n        having count(*) > {pred} order by 1,2,3', 
  'schema_name':'table_owner,table_name'}, 
 'TABLE_SUBPARTITIONS':{'sql':'\n    select\n        TABLE_OWNER owner, TABLE_NAME, to_char(count(*)) MESSAGE\n    from dba_tab_subpartitions\n    where {table_pred}\n    group by TABLE_OWNER, table_name\n    having count(*) > {pred} order by 1,2,3', 
  'schema_name':'table_owner, table_name'}, 
 'TMP_TABLE_STATS':{'sql':"\n        SELECT owner, table_name,  '' MESSAGE\n          FROM dba_tables\n        WHERE num_rows IS NOT NULL and temporary = 'Y' and {table_pred} order by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'TABLE_DEGREE':{'sql':"\n        SELECT OWNER, TABLE_NAME,  TRIM(degree) MESSAGE\n          FROM dba_tables\n         WHERE {table_pred} and TRIM(degree) <> '1' order by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'TABLE_SMALL_DEGREE':{'sql':"\nSELECT owner, table_name,  TRIM(degree) MESSAGE\nFROM dba_tables a, (SELECT tablespace_name, block_size\n  FROM dba_tablespaces) tbs\nWHERE a.tablespace_name = tbs.tablespace_name\n  AND {table_pred} and TRIM(degree) <> '1'\n  AND a.temporary = 'N'\n  AND (tbs.block_size * a.blocks)/POWER(2, 30) <= {pred} order by 1,2,3", 
  'schema_name':'a.owner,a.table_name'}, 
 'TABLE_INDEX_INCONSISTENT_DEGREE':{'sql':"SELECT a.owner, a.table_name, to_char(COUNT(*)) MESSAGE\nFROM dba_tables a,\n     dba_indexes indexes\nWHERE a.owner = indexes.table_owner\n  AND a.table_name = indexes.table_name\n  and {table_pred}\n  AND a.temporary = 'N'\n  AND TRIM(a.degree) <> TRIM(indexes.degree)\nGROUP BY a.owner, a.table_name\nHAVING COUNT(*) > 0 order by 1,2,3", 
  'schema_name':'a.owner,a.table_name'}, 
 'PARTITION_STALE_STATS':{'sql':"\n            SELECT owner, table_name,  partition_name, '' MESSAGE\n              FROM dba_tab_statistics\n              WHERE stale_stats = 'YES' and {table_pred}\n                AND partition_name IS NOT NULL and SUBPARTITION_NAME IS NULL order by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'PARTITION_LOCKED_STATS':{'sql':"\n            SELECT owner, table_name,  partition_name, '' MESSAGE\n              FROM dba_tab_statistics\n              WHERE stattype_locked IN ('ALL','DATA') and {table_pred}\n              AND partition_name IS NOT NULL  and SUBPARTITION_NAME IS NULL order by 1,2,3", 
  'schema_name':'owner,table_name'}, 
 'PARTITION_MISSING_STATS':{'sql':"\n            SELECT table_owner owner, table_name, partition_name, to_char(created,'yyyy-mm-dd') MESSAGE\n              FROM dba_tab_partitions a, dba_objects b\n              WHERE num_rows IS NULL and {table_pred}\n              and (sysdate - created) > {pred}\n              and a.table_owner = b.owner\n              and a.TABLE_NAME = b.object_name\n              and a.partition_name = b.subobject_name\n              and b.object_type = 'TABLE PARTITION' order by 1,2,3", 
  'schema_name':'table_owner,table_name'}, 
 'PARTITION_INCONSISTENT_STATS':{'sql':'\n            SELECT table_owner owner, table_name,  partition_name, to_char(blocks) MESSAGE\n              FROM dba_tab_partitions\n              WHERE num_rows = 0 and blocks > 0 and {table_pred} order by 1,2,3', 
  'schema_name':'table_owner, table_name'}, 
 'PARTITION_EMPTY_STATS':{'sql':"\n            SELECT table_owner owner, table_name, partition_name, '' MESSAGE\n              FROM dba_tab_partitions\n              WHERE num_rows = 0 and blocks = 0  and {table_pred} order by 1,2,3", 
  'schema_name':'table_owner, table_name'}, 
 'BASEFILE_LOB':{'sql':"\n            select OWNER, TABLE_NAME, to_char(count(*)) MESSAGE\n            from dba_lobs\n            where securefile <> 'YES' and {table_pred}\n            group by owner, TABLE_NAME\n            order by count(*) desc", 
  'schema_name':'owner, table_name'}, 
 'HAS_RAW':{'sql':"\n            select OWNER, TABLE_NAME, to_char(count(*)) MESSAGE\n            from dba_tab_cols\n            where data_type in ('LONG RAW','RAW') and {table_pred}\n            group by owner, table_name\n            order by count(*) desc", 
  'schema_name':'owner,TABLE_NAME'}, 
 'MISSING_PK':{'sql':"\n    select owner, table_name, '' MESSAGE\n    from dba_tables where {table_pred} and (owner, table_name) not in (\n    select owner, table_name from dba_constraints  where {table_pred} and constraint_type ='P') order by 1,2,3", 
  'schema_name':'owner,table_name'}, 
 'REDUNDANT_INDEX':{'sql':"\nWITH\n     ind_cols AS (SELECT col.index_owner, col.index_name, col.table_owner, col.table_name, a.index_type, a.uniqueness,\n                         MAX(CASE col.column_position WHEN 01 THEN      col.column_name END)||\n                         MAX(CASE col.column_position WHEN 02 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 03 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 04 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 05 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 06 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 07 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 08 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 09 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 10 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 11 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 12 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 13 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 14 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 15 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 16 THEN ':'||col.column_name END) indexed_columns\n                    FROM dba_ind_columns col,\n                         dba_indexes a\n                   WHERE {table_pred}\n                     AND a.owner = col.index_owner\n                     AND a.index_name = col.index_name\n                   GROUP BY col.index_owner,col.index_name,col.table_owner,col.table_name,a.index_type,a.uniqueness)\nSELECT r.table_owner owner, r.table_name, r.index_name||' ('||r.indexed_columns||') '||i.index_name||' ('||i.indexed_columns||')' MESSAGE\n          FROM ind_cols r,\n               ind_cols i\n         WHERE i.table_owner = r.table_owner\n           AND i.table_name = r.table_name\n           AND i.index_type = r.index_type\n           AND i.index_name != r.index_name\n           AND i.indexed_columns LIKE r.indexed_columns||':%%'\n           AND r.uniqueness = 'NONUNIQUE' order by 1,2,3", 
  'schema_name':'a.table_owner,a.table_name'}, 
 'UNINDEXED_FK':{'sql':"\nselect owner, table_name, constraint_name,\n     cname1 || nvl2(cname2,','||cname2,null) ||\n     nvl2(cname3,','||cname3,null) || nvl2(cname4,','||cname4,null) ||\n     nvl2(cname5,','||cname5,null) || nvl2(cname6,','||cname6,null) ||\n     nvl2(cname7,','||cname7,null) || nvl2(cname8,','||cname8,null)\n            columns,\n     'CREATE INDEX ' || owner || '.' || table_name || '_idx on ' || owner || '.' || table_name || '(' ||\n     cname1 || nvl2(cname2,','||cname2,null) ||\n     nvl2(cname3,','||cname3,null) || nvl2(cname4,','||cname4,null) ||\n     nvl2(cname5,','||cname5,null) || nvl2(cname6,','||cname6,null) ||\n     nvl2(cname7,','||cname7,null) || nvl2(cname8,','||cname8,null) || ') tablespace ...' CREATE_INDEX\n  from ( select b.owner,\n                b.table_name,\n                b.constraint_name,\n                max(decode( position, 1, column_name, null )) cname1,\n                max(decode( position, 2, column_name, null )) cname2,\n                max(decode( position, 3, column_name, null )) cname3,\n                max(decode( position, 4, column_name, null )) cname4,\n                max(decode( position, 5, column_name, null )) cname5,\n                max(decode( position, 6, column_name, null )) cname6,\n                max(decode( position, 7, column_name, null )) cname7,\n                max(decode( position, 8, column_name, null )) cname8,\n                count(*) col_cnt\n           from (select owner,\n                        table_name,\n                        constraint_name,\n                        column_name,\n                        position\n                   from dba_cons_columns ) a,\n                dba_constraints b\n          where a.constraint_name = b.constraint_name\n            and b.constraint_type = 'R'\n            and a.owner = b.owner\n            and {table_pred}\n          group by b.owner, b.table_name, b.constraint_name\n       ) cons\n where col_cnt > ALL\n         ( select count(*)\n             from dba_ind_columns i\n            where i.table_name = cons.table_name\n              and i.column_name in (cname1, cname2, cname3, cname4,\n                                    cname5, cname6, cname7, cname8 )\n              and i.column_position <= cons.col_cnt\n              and i.INDEX_OWNER = cons.owner\n            group by i.index_name\n         ) order by 1, 2, 3", 
  'schema_name':'b.owner,b.table_name'}, 
 'SINGLE_TABLE_INDEXES':{'sql':'\n    SELECT\n      table_owner owner,\n      table_name,\n      to_char(COUNT(*)) MESSAGE\n FROM dba_indexes\nWHERE {table_pred}\nGROUP BY\n      table_owner,\n      table_name\nHAVING COUNT(*) > {pred}\nORDER BY count(*) DESC\n    ', 
  'schema_name':'table_owner,table_name'}, 
 'INDEX_COLUMNS':{'sql':'\n    select table_owner owner, table_name, index_name, to_char(count(*)) MESSAGE\nfrom dba_ind_columns\nwhere {table_pred}\ngroup by table_owner, table_name, index_name\nhaving count(*) > {pred}\norder by 1,2,3', 
  'schema_name':'table_owner,table_name'}, 
 'UNUSABLE_INDEX':{'sql':"\nSELECT\n      TABLE_OWNER owner,\n      TABLE_NAME,\n      INDEX_NAME\nFROM dba_indexes\nwhere {table_pred}\nand status = 'UNUSABLE'\norder by 1,2,3", 
  'schema_name':'table_owner,TABLE_NAME'}, 
 'INDEX_NAMING':{'sql':"\nSELECT\n      TABLE_OWNER owner,\n      TABLE_NAME,\n      INDEX_NAME\nFROM dba_indexes\nwhere {table_pred}\nand index_name not like '{pred}%' {{escape '='}}\norder by 1,2,3", 
  'schema_name':'table_owner,table_name'}, 
 'INDEX_MISSING_STATS':{'sql':"\n    SELECT a.table_owner owner, table_name, a.index_name, to_char(created,'yyyy-mm-dd') MESSAGE\n      FROM dba_indexes a, dba_objects b\n     WHERE num_rows IS NULL\n     and {table_pred}\n     and index_type != 'LOB'\n     and (sysdate - b.created) > {pred}\n     and a.owner = b.owner\n     and a.index_name = b.object_name\n     and b.object_type = 'INDEX' order by 1,2,3", 
  'schema_name':'a.table_owner,a.table_name'}, 
 'SEQUENCE_CACHE':{'sql':'\n    SELECT\n  s.SEQUENCE_OWNER, SEQUENCE_NAME, to_char(CACHE_SIZE) MESSAGE\nfrom dba_sequences s\nwhere\n  s.max_value > 0\nand s.CACHE_SIZE < {pred}\nand {table_pred}\norder by 1,2', 
  'schema_name':'SEQUENCE_OWNER,SEQUENCE_NAME'}, 
 'SEQUENCE_ORDER':{'sql':"\nSELECT\n  s.SEQUENCE_OWNER, s.SEQUENCE_NAME\nfrom dba_sequences s, (select 1 from v$parameter where name = 'cluster_database' and value = 'TRUE')\nwhere\ns.max_value > 0\nand order_flag = 'Y'\nand {table_pred}\norder by 1,2", 
  'schema_name':'SEQUENCE_OWNER,SEQUENCE_NAME'}, 
 'SEQUENCE_INCREMENT_BY':{'sql':'\nSELECT\n  s.SEQUENCE_OWNER,SEQUENCE_NAME, to_char(INCREMENT_BY) MESSAGE\nfrom dba_sequences s\nwhere\n  s.max_value > 0\nand s.INCREMENT_BY > {pred}\nand {table_pred}\norder by 1,2', 
  'schema_name':'SEQUENCE_OWNER,SEQUENCE_NAME'}, 
 'SEQUENCE_NAMING':{'sql':"\nSELECT\n  s.SEQUENCE_OWNER,SEQUENCE_NAME\nfrom dba_sequences s\nwhere\nSEQUENCE_NAME not like '{pred}%' {{escape '='}}\nand {table_pred}\norder by 1,2", 
  'schema_name':'SEQUENCE_OWNER,SEQUENCE_NAME'}, 
 'BIND_VARIABLE':{'sql': '\nselect force_matching_signature, count(*) "Count" from gv$sqlarea where {inst_id_pred} and {sql_id_pred} group by force_matching_signature having count(*) > {pred}'}, 
 'OVER_BIND_VARIABLE':{'sql': "\nselect\n    to_char(a.force_matching_signature) FORCE_MATCHING_SIGNATURE,\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand (REGEXP_LIKE(a.sql_fulltext, ':[0-9A-Z][0-9A-Z]* *IS NULL', 'i') or REGEXP_LIKE(a.sql_fulltext, 'NVL\\(:[0-9A-Z][0-9A-Z]*', 'i'))\nand {sql_id_pred}"}, 
 'UPDATE_WHERE':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n    from\n    (\n        select p.sql_id, p.inst_id, p.child_number, p.id, operation, PARENT_ID, cost,\n          filter_predicates, access_predicates\n        from gv$sql_plan p, gv$sql s\n        where s.{sql_id_pred} and p.{sql_id_pred}\n        and p.sql_id = s.sql_id\n        and p.inst_id = s.inst_id\n        and p.child_number = s.child_number\n        and s.command_type = 6 -- update\n    )\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'UPDATE STATEMENT'\n  connect by prior id = PARENT_ID and prior sql_id = sql_id\n  and prior inst_id = inst_id and prior child_number = child_number) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 6 -- update\nand a.{sql_id_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'DELETE_WHERE':{'sql': "\nselect /*+ leading(b a) use_hash(a)*/\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n    from\n    (\n        select p.sql_id, p.inst_id, p.child_number, p.id, operation, PARENT_ID, cost,\n          filter_predicates, access_predicates\n        from gv$sql_plan p, gv$sql s\n        where s.{sql_id_pred} and p.{sql_id_pred}\n        and p.sql_id = s.sql_id\n        and p.inst_id = s.inst_id\n        and p.child_number = s.child_number\n        and s.command_type = 7 -- delete\n    )\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'DELETE STATEMENT'\n  connect by prior id = PARENT_ID and prior sql_id = sql_id\n  and prior inst_id = inst_id and prior child_number = child_number) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 7 -- delete\nand a.{sql_id_pred}"}, 
 'BITMAP_INDEX':{'sql':"\n    SELECT\n      table_owner owner,\n      table_name,\n      index_name\n FROM dba_indexes\nWHERE {table_pred} and index_type = 'BITMAP'\norder by 1,2,3\n    ", 
  'schema_name':'table_owner,table_name'}, 
 'TABLE_FILTER':{'sql': "select distinct\n                SQL_PLAN_HASH_VALUE,\n                PLAN_LINE_ID,\n                PLAN_OPERATION || ' ' || PLAN_OPTIONS PLAN_OPERATION,\n                PLAN_OBJECT_NAME,\n                PLAN_OBJECT_OWNER,\n                PLAN_CARDINALITY,\n                STARTS,\n                OUTPUT_ROWS\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {sql_id_pred}\n            and {inst_id_pred}\n            and starts is not null\n            and PLAN_OPERATION = 'TABLE ACCESS'\n            and PLAN_OPTIONS like '%ROWID'\n            and OUTPUT_ROWS/decode(starts, 0, 1, starts) < {pred}/100"}, 
 'SELECT_WHERE':{'sql': '\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a,\n      ( select inst_id, sql_id, child_number\n        from gv$sql_plan\n        where {sql_id_pred}\n        group by inst_id, sql_id, child_number\n        having max(filter_predicates) is null and max(access_predicates) is null and max(cost) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 3 -- select\nand a.{sql_id_pred}'}, 
 'PLAN_FILTER':{'sql': "\nselect  distinct PLAN_HASH_VALUE,\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom gv$sql_plan\nwhere operation = 'FILTER'\nand {sql_id_pred}\nand {inst_id_pred}"}, 
 'PARALLEL_PLAN':{'sql': "\nselect distinct\n        PLAN_HASH_VALUE,\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom gv$sql_plan\nwhere operation = 'PX COORDINATOR'\nand {sql_id_pred}\nand {inst_id_pred}"}, 
 'INDEX_NULL':{'sql':"\nselect a.table_owner owner, a.table_name, a.index_name\nfrom\n(\n        select\n            table_owner,\n            table_name,\n            index_name,\n            max(column_position) cols\n        from\n            dba_ind_columns ic\n        where {table_pred}\n        group by table_owner, table_name, index_name\n) a,\n(select\n    ic.table_owner,\n    ic.table_name,\n    ic.index_name,\n    count(*) null_cols\nfrom\n    dba_ind_columns ic, dba_tab_cols c, sys.col_usage$ usage, dba_objects obj\nwhere {table_pred}\nand ic.table_owner = c.owner\nand ic.table_name = c.table_name\nand c.nullable = 'Y'\nand ic.column_name = c.column_name\nand usage.NULL_PREDS > 0\nand usage.OBJ# = obj.object_id\nand obj.owner = ic.table_owner\nand obj.object_name = ic.table_name\nand usage.INTCOL# = c.column_id\ngroup by ic.table_owner, ic.table_name, ic.index_name) b\nwhere\n    a.table_owner = b.table_owner\nand a.table_name = b.table_name\nand a.index_name = b.index_name\nand a.cols = null_cols order by 1,2,3", 
  'schema_name':'ic.table_owner,ic.table_name'}, 
 'TABLE_NOPARTITION':{'sql':"\nselect\n    owner,\n    segment_name Table_name,\n    tablespace_name,\n    to_char(round(bytes/1073741824,1)) MESSAGE\nfrom\n    dba_segments\nwhere\n    partition_name is null\nand segment_type = 'TABLE'\nand {table_pred}\nand bytes/1073741824 > {pred}\norder by bytes desc", 
  'schema_name':'owner,segment_name'}, 
 'MULTI_RANGE_KEY':{'sql':"\nselect owner, table_name, partitioning_key_count,\n(select\n    max(case column_position when 1 then        column_name end) ||\n    max(case column_position when 2 then ':' || column_name end) ||\n    max(case column_position when 3 then ':' || column_name end) ||\n    max(case column_position when 4 then ':' || column_name end) ||\n    max(case column_position when 5 then ':' || column_name end) ||\n    max(case column_position when 6 then ':' || column_name end)\nfrom dba_PART_KEY_COLUMNS k where p.owner = k.owner and k.OBJECT_TYPE = 'TABLE') MESSAGE\nfrom DBA_PART_TABLES p\nwhere PARTITIONING_KEY_COUNT > 1\nand {table_pred} order by 1,2", 
  'schema_name':'owner,table_name'}, 
 'SKEW_PARTITION':{'sql':"\nselect\n    table_owner owner,\n    table_name,\n    to_char(max(blocks)) || ':' || to_char(min(blocks)) MESSAGE\nfrom\n    dba_tab_partitions\nwhere num_rows > 0 and {table_pred}\ngroup by table_owner, table_name\nhaving max(blocks)/min(blocks) > {pred} order by 1,2", 
  'schema_name':'table_owner,table_name'}, 
 'GLOBAL_INDEX':{'sql':"\nselect t.owner, t.table_name, i.index_name,\n    (SELECT\n        MAX(CASE col.column_position WHEN 01 THEN      col.column_name END)||\n        MAX(CASE col.column_position WHEN 02 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 03 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 04 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 05 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 06 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 07 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 08 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 09 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 10 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 11 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 12 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 13 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 14 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 15 THEN ':'||col.column_name END)||\n        MAX(CASE col.column_position WHEN 16 THEN ':'||col.column_name END)\n    FROM dba_ind_columns col\n    WHERE i.owner = col.index_owner\n    AND i.index_name = col.index_name) MESSAGE\nfrom dba_indexes i, dba_tables t\nwhere i.partitioned = 'NO'\nand i.uniqueness <> 'UNIQUE'\nand t.partitioned = 'YES'\nand i.table_owner = t.owner\nand i.table_name = t.table_name\nand {table_pred} order by 1, 2, 3", 
  'schema_name':'t.owner,t.table_name'}, 
 'SELECT_STAR':{'sql': "\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(regexp_replace(translate(regexp_replace(sql_text,'--.*$',''),chr(10)||chr(11)||chr(13), ' '),'/\\*.*\\*/',''), 'select[[:space:]]+\\*', 'i')\nand {sql_id_pred}"}, 
 'WITH_HINT':{'sql':"\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand (regexp_like(sql_text, '--\\+') or regexp_like(translate(sql_text,chr(10)||chr(11)||chr(13), ' '),'/\\*\\+.*\\*/'))\nand {sql_id_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'SQL_PROFILE':{'sql': '\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a\nwhere a.{inst_id_pred}\nand {sql_id_pred}\nand (SQL_PROFILE is not null or sql_plan_baseline is not null)'}, 
 'SKEW_COLUMN':{'sql':"select OWNER, TABLE_NAME, COLUMN_NAME, to_char(max(pct)) MESSAGE from\n(\nselect\n    OWNER,\n    TABLE_NAME,\n    COLUMN_NAME,\n\tendpoint_value\t\t\t\trow_value,\n\tround(RATIO_TO_REPORT(row_count) OVER (partition by owner, table_name, column_name) * 100) AS pct\nfrom (\n        select\n            h.OWNER,\n            h.TABLE_NAME,\n            h.COLUMN_NAME,\n            h.endpoint_value,\n            h.endpoint_number -\n            nvl(lag(endpoint_number,1) over (partition by h.owner, h.table_name, h.column_name\n                order by endpoint_number\n            ),0)\t\t\t\trow_count\n        from\n            dba_tab_histograms h, dba_tab_columns c\n        where\n           {table_pred}\n    and    h.owner = c.owner\n    and    h.table_name = c.table_name\n    and    h.column_name = c.column_name\n    and    c.histogram != 'NONE'\n    )\n) group by OWNER, TABLE_NAME, COLUMN_NAME\nhaving max(pct) > {pred} order by 1,2,3", 
  'schema_name':'c.owner, c.table_name'}, 
 'WRONG_HISTOGRAM':{'sql':"select\n    OWNER,\n    TABLE_NAME,\n    COLUMN_NAME\nfrom\n    dba_tab_columns\nwhere\n    {table_pred}\nand num_distinct > 1\nand histogram != 'NONE'\nand num_buckets = 1\norder by 1,2,3", 
  'schema_name':'owner, table_name'}, 
 'NESTED_BLOCK':{'sql': '\nselect /*+ leading(b a) use_hash(a)*/\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a, (\n        select distinct inst_id, sql_id, child_number\n        from\n                gv$sql_plan p\n        where\n        p.other_xml is not null and {inst_id_pred} and {sql_id_pred}\n        and (SELECT /*+ opt_param(\'parallel_execution_enabled\', \'false\') */\n                      count(*)\n                      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), \'/*/outline_data/hint\'))) d\n                      where regexp_like(extractvalue(value(d), \'/hint\'), \'^OUTLINE\\(@"SEL\\$[[:digit:]]"\\)\')\n              ) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.{sql_id_pred}'}, 
 'MANY_TABLE':{'sql': "\nselect /*+ leading(b a) use_hash(a)*/\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sql a, (\n        select distinct inst_id, sql_id, child_number\n        from\n                gv$sql_plan p\n        where\n        p.other_xml is not null and {inst_id_pred} and {sql_id_pred}\n        and (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */\n                count(*)\n                FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), '/*/outline_data/hint'))) d\n                where regexp_like(extractvalue(value(d), '/hint'), '^(FULL|INDEX)')) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.{sql_id_pred}"}, 
 'LEFT_WILDCARD':{'sql': "\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand regexp_like(translate(sql_text,chr(10)||chr(11)||chr(13), ' '),'like[[:space:]]+''%')\nand {sql_id_pred}"}, 
 'INSERT_VALUE':{'sql': "\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(regexp_replace(translate(regexp_replace(sql_text,'--.*$',''),chr(10)||chr(11)||chr(13), ' '),'/\\*.*\\*/',''), 'insert[[:space:]]+into[^(]+values', 'i')\nand {sql_id_pred}"}, 
 'UNUSED_INDEX':{'sql':"\n    select u.name owner, t.name table_name, io.name index_name,\nto_char(ou.start_monitoring,'yyyy-mm-dd hh24:mi:ss') start_monitoring,\nto_char(ou.end_monitoring, 'yyyy-mm-dd hh24:mi:ss') end_monitoring\nfrom sys.user$ u, sys.obj$ io, sys.obj$ t, sys.ind$ i, sys.object_usage ou\nwhere i.obj# = ou.obj#\nand io.obj# = ou.obj#\nand t.obj# = i.bo#\nand u.user# = io.owner#\nand decode(bitand(i.flags, 65536), 0, 'NO', 'YES') = 'YES'\nand decode(bitand(ou.flags, 1), 0, 'NO', 'YES')='NO'\nand {table_pred}\norder by 1,2,3", 
  'schema_name':'u.name,t.name'}, 
 'MANY_BINDS':{'sql': "\nselect\n    a.SQL_ID,\n    PLAN_HASH_VALUE,\n    executions EXECUTIONS,\n    round(elapsed_time/decode(a.executions, 0, 1, a.executions)/1e3) ELAPSED_TIME_PER_EXECUTION,\n    round(cpu_time/decode(executions, 0, 1, a.executions)/1e3) CPU_TIME_PER_EXECUTION,\n    round(buffer_gets/decode(a.executions, 0, 1, a.executions)) BUFFER_GETS_PER_EXECUTION,\n    round(disk_reads/decode(a.executions, 0, 1, a.executions)) READS_PER_EXECUTION\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(sql_text, 'in[^(]+\\((:[[:alnum:]_]+,[[:space:]]*){{{pred}}}', 'i')\nand {sql_id_pred}"}, 
 'OBJECT_CREATED':{'sql':"\nselect\n    owner object_owner, object_type, object_name, subobject_name, to_char(created,'yyyy-mm-dd hh24:mi:ss') MESSAGE\nfrom\n    dba_objects\nwhere {table_pred}\nand sysdate - created < {pred} order by 1,2,3", 
  'schema_name':'owner,object_name'}, 
 'OBJECT_DDL':{'sql':"\nselect\n    owner object_owner, object_type, object_name, subobject_name, to_char(last_ddl_time,'yyyy-mm-dd hh24:mi:ss') MESSAGE\nfrom\n    dba_objects\nwhere {table_pred}\nand sysdate - last_ddl_time < {pred}\nand sysdate - created > {pred} order by 1,2,3", 
  'schema_name':'owner,object_name'}, 
 'JOIN_NULL':{'sql':"\nselect\n    cols.owner, cols.table_name, cols.column_name, to_char(usage.EQUIJOIN_PREDS) MESSAGE\nfrom\n    sys.col_usage$ usage,\n    dba_objects obj,\n    dba_tab_cols cols\nwhere\n    obj.object_type = 'TABLE'\nand usage.EQUIJOIN_PREDS > {pred}\nand {table_pred}\nand cols.nullable = 'Y'\nand num_nulls = 0\nand usage.OBJ# = obj.object_id\nand obj.owner = cols.owner\nand obj.object_name = cols.table_name\nand usage.INTCOL# = cols.column_id\norder by 1, 2, 3", 
  'schema_name':'cols.owner, cols.table_name'}, 
 'FOR_UPDATE':{'sql': "\nselect distinct\n        PLAN_HASH_VALUE,\n        ID,\n        OPERATION || ' ' || OPTIONS OPERATION,\n        OBJECT_OWNER,\n        OBJECT_NAME,\n        COST,\n        CARDINALITY,\n        ACCESS_PREDICATES,\n        FILTER_PREDICATES\nfrom gv$sql_plan\nwhere operation = 'FOR UPDATE'\nand {sql_id_pred}\nand {inst_id_pred}"}, 
 'CHAR_COL':{'sql':"\n        select OWNER, TABLE_NAME, to_char(count(*)) MESSAGE\n        from dba_tab_cols\n        where data_type in ('CHAR') and {table_pred}\n        group by owner, table_name\n        order by count(*) desc", 
  'schema_name':'owner,TABLE_NAME'}}
# okay decompiling ./restful/hawkeye/sqlaudit/enum/oracle_single_sql_audit_enum.pyc

# uncompyle6 version 3.2.3
# Python bytecode 3.6 (3379)
# Decompiled from: Python 2.7.5 (default, Jul 13 2018, 13:06:57) 
# [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)]
# Embedded file name: ./sqlaudit/enum/oracle_problem_template_enum.py
# Compiled at: 2018-08-23 19:33:14
# Size of source mod 2**32: 33255 bytes
ProblemTemplateJSON = {'MULTI_PLAN':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      (select sql_id\n        from gv$sql\n        where {schema_pred} and {inst_id_pred}\n        group by sql_id having count(distinct plan_hash_value) > 1) b\nwhere\n    a.sql_id = b.sql_id\nand {inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'BAD_PLAN':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      (select inst_id, sql_id, child_number\n        from gv$sql_plan\n        where {inst_id_pred}\n        and {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'TYPE_CONVERSION':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      (select inst_id, sql_id, child_number\n        from gv$sql_plan\n        where {inst_id_pred}\n        and {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'CARDINALITY_GAP':{'sql':"select count(distinct key) COUNT from (select\n                  *\n                  from\n                    (select /*+ leading(b a) use_hash(a)*/\n                            a.KEY,\n                            a.SQL_ID,\n                            a.PLAN_LINE_ID,\n                            a.PLAN_OPERATION,\n                            a.PLAN_OPTIONS,\n                            a.PLAN_OBJECT_NAME,\n                            a.PLAN_OBJECT_TYPE,\n                            a.PLAN_OBJECT_OWNER,\n                            a.PLAN_CARDINALITY,\n                            a.STARTS,\n                            a.OUTPUT_ROWS,\n                            a.PLAN_PARENT_ID,\n                            b.SQL_PLAN_HASH_VALUE,\n                            round(b.ELAPSED_TIME/1e6) ELAPSED_TIME,\n                            round(b.CPU_TIME/1e6) CPU_TIME,\n                            b.BUFFER_GETS,\n                            b.DISK_READS\n                         from gv$sql_plan_monitor a, gv$sql_monitor b\n                            where a.{inst_id_pred} and b.{inst_id_pred} and b.{schema_pred}\n                            and a.status like 'DONE%'\n                            and b.status like 'DONE%'\n                            and a.key = b.key\n                            )\n                        where connect_by_isleaf = 1\n                        start with PLAN_LINE_ID = 0\n                        connect by NOCYCLE prior PLAN_LINE_ID = PLAN_PARENT_ID and\n                                prior key = key\n                        ) where\n                        (starts = 1 or (PLAN_OPERATION = 'TABLE ACCESS' and PLAN_OPTIONS in ('FULL','STORAGE FULL','INMEMORY FULL')))\n                        and\n                        (PLAN_CARDINALITY/decode(OUTPUT_ROWS,0,1,OUTPUT_ROWS) > {pred} or OUTPUT_ROWS/PLAN_CARDINALITY > {pred})", 
  'schema_name':'username'}, 
 'DATAFLOW_GAP':{'sql':"select count(distinct key) COUNT from (\n                select\n                    c.*,\n                    prior OUTPUT_ROWS PARENT_OUTPUT_ROWS,\n                    prior PLAN_OPTIONS PARENT_PLAN_OPTIONS,\n                    prior PLAN_OPERATION PARENT_PLAN_OPERATION\n                from (select /*+ leading(b a) use_hash(a)*/\n                    a.KEY,\n                    a.SQL_ID,\n                    a.PLAN_LINE_ID,\n                    a.PLAN_OPERATION,\n                    a.PLAN_OPTIONS,\n                    a.PLAN_OBJECT_NAME,\n                    a.PLAN_OBJECT_TYPE,\n                    a.PLAN_OBJECT_OWNER,\n                    a.PLAN_CARDINALITY,\n                    a.STARTS,\n                    a.OUTPUT_ROWS,\n                    a.PLAN_PARENT_ID,\n                    b.SQL_PLAN_HASH_VALUE,\n                    round(b.ELAPSED_TIME/1e6) ELAPSED_TIME,\n                    round(b.CPU_TIME/1e6) CPU_TIME,\n                    b.BUFFER_GETS,\n                    b.DISK_READS\n                 from gv$sql_plan_monitor a, gv$sql_monitor b\n                    where a.{inst_id_pred} and b.{inst_id_pred} and b.{schema_pred}\n                    and a.status like 'DONE%'\n                    and b.status like 'DONE%'\n                    and a.key = b.key\n                    ) c\n                where connect_by_isleaf = 1\n                start with PLAN_LINE_ID = 0\n                connect by NOCYCLE prior PLAN_LINE_ID = PLAN_PARENT_ID and\n                        prior key = key\n                ) where\n                (PARENT_PLAN_OPTIONS not in ('GROUP BY','UNIQUE','AGGREGATE','STOPKEY','ORDER BY STOPKEY') and PARENT_PLAN_OPERATION not like '%STATEMENT')\n                and OUTPUT_ROWS/decode(PARENT_OUTPUT_ROWS,0,1,PARENT_OUTPUT_ROWS) > {pred}", 
  'schema_name':'username'}, 
 'INDEX_ROWS':{'sql':"select count(*) COUNT\n         from (select distinct key\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {inst_id_pred}\n            and PLAN_OPERATION = 'INDEX'\n            and OUTPUT_ROWS/decode(STARTS,0,1,STARTS) > {pred}\n         ) a, gv$sql_monitor b\n            where b.{inst_id_pred} and b.{schema_pred}\n            and b.status like 'DONE%'\n            and a.key = b.key", 
  'schema_name':'username'}, 
 'OPERATION_STARTS':{'sql':"select count(*) COUNT\n         from (select distinct key\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {inst_id_pred}\n            and starts > {pred}\n         ) a, gv$sql_monitor b\n            where b.{inst_id_pred} and b.{schema_pred}\n            and b.status like 'DONE%'\n            and a.key = b.key", 
  'schema_name':'username'}, 
 'TABLE_OLD_STATS':{'sql':"\n    SELECT COUNT(*) COUNT\n      FROM dba_tables\n     WHERE {schema_pred} and temporary = 'N' and last_analyzed < SYSDATE-{pred}", 
  'schema_name':'owner'}, 
 'TABLE_STALE_STATS':{'sql':"\n    SELECT COUNT(*) COUNT\n      FROM dba_tab_statistics\n     WHERE stale_stats = 'YES' and {schema_pred} and partition_name IS NULL and SUBPARTITION_NAME IS NULL\n     and (owner, TABLE_NAME ) not in (select owner, TABLE_NAME from dba_tables where {schema_pred} and temporary = 'Y')", 
  'schema_name':'owner'}, 
 'TABLE_LOCKED_STATS':{'sql':"\n    SELECT COUNT(*) COUNT\n      FROM dba_tab_statistics\n     WHERE stattype_locked IN ('ALL','DATA') and {schema_pred} and partition_name IS NULL and SUBPARTITION_NAME IS NULL\n    and (owner, TABLE_NAME ) not in (select owner, TABLE_NAME from dba_tables where {schema_pred} and temporary = 'Y')", 
  'schema_name':'owner'}, 
 'TABLE_MISSING_STATS':{'sql':"\n    SELECT COUNT(*) COUNT\n          FROM dba_tables a, dba_objects b\n         WHERE num_rows IS NULL and a.temporary = 'N' and a.{schema_pred}\n         and (sysdate - created) > {pred}\n         and a.owner = b.owner\n         and a.TABLE_NAME = b.object_name\n          and b.object_type = 'TABLE'", 
  'schema_name':'owner'}, 
 'TABLE_INCONSISTENT_STATS':{'sql':"\n    SELECT COUNT(*) COUNT\n      FROM dba_tables\n     WHERE num_rows = 0 and blocks > {pred} and temporary = 'N' and {schema_pred} ", 
  'schema_name':'owner'}, 
 'TABLE_EMPTY_STATS':{'sql':"\nSELECT COUNT(*) COUNT\n  FROM dba_tables\n WHERE num_rows = 0 and blocks = 0 and temporary = 'N' and {schema_pred} ", 
  'schema_name':'owner'}, 
 'TABLE_PARTITIONS':{'sql':'\nselect count(*) COUNT\nfrom\n(\n    select\n        COUNT(*) COUNT\n    from dba_tab_partitions\n    where {schema_pred}\n    group by table_owner, table_name\n    having count(*) > {pred}\n)', 
  'schema_name':'table_owner'}, 
 'TABLE_SUBPARTITIONS':{'sql':'\nselect count(*) COUNT\nfrom\n(\n    select\n        COUNT(*) COUNT\n    from dba_tab_subpartitions\n    where {schema_pred}\n    group by table_owner, table_name\n    having count(*) > {pred})', 
  'schema_name':'table_owner'}, 
 'TMP_TABLE_STATS':{'sql':"\n    SELECT count(*) COUNT\n      FROM dba_tables\n    WHERE num_rows IS NOT NULL and temporary = 'Y' and {schema_pred}", 
  'schema_name':'owner'}, 
 'TABLE_DEGREE':{'sql':"\n    SELECT count(*) COUNT\n      FROM dba_tables\n     WHERE {schema_pred} and TRIM(degree) <> '1'", 
  'schema_name':'owner'}, 
 'TABLE_SMALL_DEGREE':{'sql':"\nSELECT count(*) COUNT\nFROM dba_tables t, (SELECT tablespace_name, block_size\n  FROM dba_tablespaces) tbs\nWHERE t.tablespace_name = tbs.tablespace_name\n  AND {schema_pred} and TRIM(degree) <> '1'\n  AND (tbs.block_size * t.blocks)/POWER(2, 30) <= {pred}", 
  'schema_name':'owner'}, 
 'TABLE_INDEX_INCONSISTENT_DEGREE':{'sql':"SELECT count(*) COUNT\nFROM dba_tables tables,\n     dba_indexes indexes\nWHERE tables.owner = indexes.table_owner\n  AND tables.table_name = indexes.table_name\n  and tables.{schema_pred}\n  and indexes.table_{schema_pred}\n  and indexes.index_name not like 'SYS_IL%'\n  AND TRIM(tables.degree) <> TRIM(indexes.degree)\nGROUP BY tables.owner, tables.table_name\nHAVING COUNT(*) > 0", 
  'schema_name':'owner'}, 
 'PARTITION_STALE_STATS':{'sql':"\n            SELECT count(*) COUNT\n              FROM dba_tab_statistics\n              WHERE stale_stats = 'YES' and {schema_pred}\n                AND partition_name IS NOT NULL and SUBPARTITION_NAME IS NULL", 
  'schema_name':'owner'}, 
 'PARTITION_LOCKED_STATS':{'sql':"\n            SELECT count(*) COUNT\n              FROM dba_tab_statistics\n              WHERE stattype_locked IN ('ALL','DATA') and {schema_pred}\n              AND partition_name IS NOT NULL  and SUBPARTITION_NAME IS NULL", 
  'schema_name':'owner'}, 
 'PARTITION_MISSING_STATS':{'sql':"\n            SELECT count(*) COUNT\n              FROM dba_tab_partitions a, dba_objects b\n              WHERE num_rows IS NULL and {schema_pred}\n              and (sysdate - created) > {pred}\n              and a.table_owner = b.owner\n              and a.TABLE_NAME = b.object_name\n              and a.partition_name = b.subobject_name\n              and b.object_type = 'TABLE PARTITION'", 
  'schema_name':'table_owner'}, 
 'PARTITION_INCONSISTENT_STATS':{'sql':'\n            SELECT count(*) COUNT\n              FROM dba_tab_partitions\n              WHERE num_rows = 0 and blocks > 0 and {schema_pred}', 
  'schema_name':'table_owner'}, 
 'PARTITION_EMPTY_STATS':{'sql':'\n            SELECT count(*) COUNT\n              FROM dba_tab_partitions\n              WHERE num_rows = 0 and blocks = 0 and {schema_pred}', 
  'schema_name':'table_owner'}, 
 'BASEFILE_LOB':{'sql':"\nselect count(*) COUNT\nfrom (\n    select count(*) COUNT\n    from dba_lobs a\n    where securefile <> 'YES' and {schema_pred}\n    group by owner, TABLE_NAME)", 
  'schema_name':'owner'}, 
 'HAS_RAW':{'sql':"\nselect count(*) COUNT\nfrom dba_tab_cols\nwhere data_type in ('LONG RAW','RAW') and {schema_pred}", 
  'schema_name':'owner'}, 
 'MISSING_PK':{'sql':"\nselect count(*) COUNT\nfrom dba_tables where {schema_pred} and (owner, table_name) not in (\nselect owner, table_name from dba_constraints  where {schema_pred} and constraint_type ='P')", 
  'schema_name':'owner'}, 
 'REDUNDANT_INDEX':{'sql':"\nWITH\n     ind_cols AS (SELECT col.index_owner, col.index_name, col.table_owner, col.table_name, a.index_type, a.uniqueness,\n                         MAX(CASE col.column_position WHEN 01 THEN      col.column_name END)||\n                         MAX(CASE col.column_position WHEN 02 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 03 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 04 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 05 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 06 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 07 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 08 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 09 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 10 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 11 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 12 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 13 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 14 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 15 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 16 THEN ':'||col.column_name END) indexed_columns\n                    FROM dba_ind_columns col,\n                         dba_indexes a\n                   WHERE {schema_pred}\n                     AND a.owner = col.index_owner\n                     AND a.index_name = col.index_name\n                   GROUP BY col.index_owner,col.index_name,col.table_owner,col.table_name,a.index_type,a.uniqueness)\nSELECT count(*) COUNT\n          FROM ind_cols r,\n               ind_cols i\n         WHERE i.table_owner = r.table_owner\n           AND i.table_name = r.table_name\n           AND i.index_type = r.index_type\n           AND i.index_name != r.index_name\n           AND i.indexed_columns LIKE r.indexed_columns||':%%'\n           AND r.uniqueness = 'NONUNIQUE'", 
  'schema_name':'owner'}, 
 'REDUNDANT_INDEX':{'sql':"\nWITH\n     ind_cols AS (SELECT col.index_owner, col.index_name, col.table_owner, col.table_name, a.index_type, a.uniqueness,\n                         MAX(CASE col.column_position WHEN 01 THEN      col.column_name END)||\n                         MAX(CASE col.column_position WHEN 02 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 03 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 04 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 05 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 06 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 07 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 08 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 09 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 10 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 11 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 12 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 13 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 14 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 15 THEN ':'||col.column_name END)||\n                         MAX(CASE col.column_position WHEN 16 THEN ':'||col.column_name END) indexed_columns\n                    FROM dba_ind_columns col,\n                         dba_indexes a\n                   WHERE {schema_pred}\n                     AND a.owner = col.index_owner\n                     AND a.index_name = col.index_name\n                   GROUP BY col.index_owner,col.index_name,col.table_owner,col.table_name,a.index_type,a.uniqueness)\nSELECT count(*) COUNT\n          FROM ind_cols r,\n               ind_cols i\n         WHERE i.table_owner = r.table_owner\n           AND i.table_name = r.table_name\n           AND i.index_type = r.index_type\n           AND i.index_name != r.index_name\n           AND i.indexed_columns LIKE r.indexed_columns||':%%'\n           AND r.uniqueness = 'NONUNIQUE'", 
  'schema_name':'owner'}, 
 'UNINDEXED_FK':{'sql':"\nselect count(*) COUNT  from ( select b.owner,\n                b.table_name,\n                b.constraint_name,\n                max(decode( position, 1, column_name, null )) cname1,\n                max(decode( position, 2, column_name, null )) cname2,\n                max(decode( position, 3, column_name, null )) cname3,\n                max(decode( position, 4, column_name, null )) cname4,\n                max(decode( position, 5, column_name, null )) cname5,\n                max(decode( position, 6, column_name, null )) cname6,\n                max(decode( position, 7, column_name, null )) cname7,\n                max(decode( position, 8, column_name, null )) cname8,\n                count(*) col_cnt\n           from (select owner,\n                        constraint_name,\n                        column_name,\n                        position\n                   from dba_cons_columns ) a,\n                dba_constraints b\n          where a.constraint_name = b.constraint_name\n            and b.constraint_type = 'R'\n            and a.owner = b.owner\n            and a.{schema_pred}\n            and b.{schema_pred}\n          group by b.owner, b.table_name, b.constraint_name\n       ) cons\n where col_cnt > ALL\n         ( select count(*)\n             from dba_ind_columns i\n            where i.table_name = cons.table_name\n              and i.column_name in (cname1, cname2, cname3, cname4,\n                                    cname5, cname6, cname7, cname8 )\n              and i.column_position <= cons.col_cnt\n              and i.INDEX_OWNER = cons.owner\n            group by i.index_name)", 
  'schema_name':'owner'}, 
 'UNUSED_INDEX':{'sql':"select count(*) COUNT\nfrom sys.user$ u, sys.obj$ io, sys.obj$ t, sys.ind$ i, sys.object_usage ou\nwhere i.obj# = ou.obj#\nand io.obj# = ou.obj#\nand t.obj# = i.bo#\nand u.user# = io.owner#\nand decode(bitand(i.flags, 65536), 0, 'NO', 'YES') = 'YES'\nand decode(bitand(ou.flags, 1), 0, 'NO', 'YES')='NO'\nand u.{schema_pred}", 
  'schema_name':'name'}, 
 'SINGLE_TABLE_INDEXES':{'sql':"\nSELECT\n    count(*) COUNT\n FROM dba_indexes\nWHERE {schema_pred}\nand index_name not like 'SYS_IL%'\nGROUP BY\n      table_owner,\n      table_name\nHAVING COUNT(*) > {pred}", 
  'schema_name':'table_owner'}, 
 'INDEX_COLUMNS':{'sql':'\nselect count(*) COUNT\nfrom dba_ind_columns\nwhere {schema_pred}\ngroup by table_owner, table_name, index_name\nhaving count(*) > {pred}', 
  'schema_name':'table_owner'}, 
 'UNUSABLE_INDEX':{'sql':"\nSELECT\ncount(*) COUNT\nFROM dba_indexes\nwhere {schema_pred}\nand status = 'UNUSABLE'", 
  'schema_name':'table_owner'}, 
 'INDEX_NAMING':{'sql':"\nSELECT\ncount(*) COUNT\nFROM dba_indexes\nwhere {schema_pred}\nand index_name not like '{pred}%' {{escape '='}}", 
  'schema_name':'table_owner'}, 
 'INDEX_MISSING_STATS':{'sql':"\nSELECT count(*) COUNT\n      FROM dba_indexes a, dba_objects b\n     WHERE index_type != 'LOB' and num_rows IS NULL\n     and a.{schema_pred}\n     and (sysdate - b.created) > {pred}\n     and a.owner = b.owner\n     and a.index_name = b.object_name\n     and b.object_type = 'INDEX'", 
  'schema_name':'table_owner'}, 
 'SEQUENCE_CACHE':{'sql':'\n    SELECT\ncount(*) COUNT\nfrom dba_sequences s\nwhere\n  s.max_value > 0\nand s.CACHE_SIZE < {pred}\nand {schema_pred}', 
  'schema_name':'SEQUENCE_OWNER'}, 
 'SEQUENCE_ORDER':{'sql':"\nSELECT\ncount(*) COUNT\nfrom dba_sequences s, (select 1 from v$parameter where name = 'cluster_database' and value = 'TRUE')\nwhere\ns.max_value > 0\nand order_flag = 'Y'\nand {schema_pred}", 
  'schema_name':'SEQUENCE_OWNER'}, 
 'SEQUENCE_INCREMENT_BY':{'sql':'\nSELECT\ncount(*) COUNT\nfrom dba_sequences s\nwhere\n  s.max_value > 0\nand abs(s.INCREMENT_BY) > {pred}\nand {schema_pred}', 
  'schema_name':'SEQUENCE_OWNER'}, 
 'SEQUENCE_NAMING':{'sql':"\nSELECT\n    count(*) COUNT\nfrom dba_sequences s\nwhere\nSEQUENCE_NAME not like '{pred}%' {{escape '='}}\nand {schema_pred}", 
  'schema_name':'SEQUENCE_OWNER'}, 
 'BIND_VARIABLE':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sqlarea a, (select force_matching_signature, count(*) "Count" from gv$sqlarea where {inst_id_pred} and {schema_pred} group by force_matching_signature having count(*) > {pred}) b\nwhere\na.{inst_id_pred}\nand a.force_matching_signature = b.force_matching_signature\nand {sql_text_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'OVER_BIND_VARIABLE':{'sql':"\nselect\ncount(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(a.sql_fulltext, ':[0-9A-Z][0-9A-Z]* *IS NULL', 'i')\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'UPDATE_WHERE':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n    from\n    (\n        select p.sql_id, p.inst_id, p.child_number, p.id, operation, PARENT_ID, cost,\n          filter_predicates, access_predicates\n        from gv$sql_plan p, gv$sql s\n        where s.{schema_pred}\n        and p.sql_id = s.sql_id\n        and p.inst_id = s.inst_id\n        and p.child_number = s.child_number\n        and s.command_type = 6 -- update\n    )\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'UPDATE STATEMENT'\n  connect by prior id = PARENT_ID and prior sql_id = sql_id\n  and prior inst_id = inst_id and prior child_number = child_number) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 6 -- update\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'DELETE_WHERE':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n    from\n    (\n        select p.sql_id, p.inst_id, p.child_number, p.id, operation, PARENT_ID, cost,\n          filter_predicates, access_predicates\n        from gv$sql_plan p, gv$sql s\n        where s.{schema_pred}\n        and p.sql_id = s.sql_id\n        and p.inst_id = s.inst_id\n        and p.child_number = s.child_number\n        and s.command_type = 7 -- delete\n    )\n    where connect_by_isleaf = 1 and level = 3 and CONNECT_BY_ROOT cost > {pred}\n      and operation = 'TABLE ACCESS' and filter_predicates is null and access_predicates is null\n    start with id = 0 and operation = 'UPDATE STATEMENT'\n  connect by prior id = PARENT_ID and prior sql_id = sql_id\n  and prior inst_id = inst_id and prior child_number = child_number) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 7 -- delete\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'BITMAP_INDEX':{'sql':"\n    SELECT\n    count(*) COUNT\n FROM dba_indexes\nWHERE {schema_pred} and index_type = 'BITMAP'", 
  'schema_name':'table_owner'}, 
 'TABLE_FILTER':{'sql':"select count(*) COUNT\n         from (select distinct key\n            from gv$sql_plan_monitor\n            where status like 'DONE%'\n            and {inst_id_pred}\n            and starts is not null\n            and {inst_id_pred}\n            and starts is not null\n            and PLAN_OPERATION = 'TABLE ACCESS'\n            and PLAN_OPTIONS like '%ROWID'\n            and OUTPUT_ROWS/decode(starts, 0, 1, starts) < {pred}/100\n            ) a, gv$sql_monitor b\n            where b.{inst_id_pred} and b.{schema_pred}\n            and b.status like 'DONE%'\n            and a.key = b.key", 
  'schema_name':'username'}, 
 'SELECT_WHERE':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select inst_id, sql_id, child_number\n        from gv$sql_plan\n        group by inst_id, sql_id, child_number\n        having max(filter_predicates) is null and max(access_predicates) is null  and max(cost) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand a.command_type = 3 -- select\nand {sql_text_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'PLAN_FILTER':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n        from gv$sql_plan\n        where operation = 'FILTER' and {inst_id_pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'PARALLEL_PLAN':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n        from gv$sql_plan\n        where operation = 'PX COORDINATOR' and {inst_id_pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'INDEX_NULL':{'sql':"\nselect COUNT(*) COUNT\nfrom\n(\n        select\n            table_owner,\n            table_name,\n            index_name,\n            max(column_position) cols\n        from\n            dba_ind_columns\n        where {schema_pred}\n        group by table_owner, table_name, index_name\n) a,\n(select\n    ic.table_owner,\n    ic.table_name,\n    ic.index_name,\n    count(*) null_cols\nfrom\n    dba_ind_columns ic, dba_tab_cols c, sys.col_usage$ usage, dba_objects obj\nwhere ic.{schema_pred}\nand ic.table_owner = c.owner\nand ic.table_name = c.table_name\nand c.nullable = 'Y'\nand ic.column_name = c.column_name\nand usage.NULL_PREDS > 0\nand usage.OBJ# = obj.object_id\nand obj.owner = ic.table_owner\nand obj.object_name = ic.table_name\nand usage.INTCOL# = c.column_id\ngroup by ic.table_owner, ic.table_name, ic.index_name) b\nwhere\n    a.table_owner = b.table_owner\nand a.table_name = b.table_name\nand a.index_name = b.index_name\nand a.cols = null_cols", 
  'schema_name':'table_owner'}, 
 'TABLE_NOPARTITION':{'sql':"\nselect\n    count(*) COUNT\nfrom\n    dba_segments\nwhere\n    partition_name is null\nand segment_type = 'TABLE'\nand {schema_pred}\nand bytes/1073741824 > {pred}", 
  'schema_name':'owner'}, 
 'MULTI_RANGE_KEY':{'sql':'\nselect     count(*) COUNT\nfrom DBA_PART_TABLES p\nwhere PARTITIONING_KEY_COUNT > 1\nand {schema_pred}', 
  'schema_name':'owner'}, 
 'SKEW_PARTITION':{'sql':'\nselect count(*) COUNT\nfrom\n(select\n    count(*) COUNT\nfrom\n    dba_tab_partitions\nwhere num_rows > 0 and {schema_pred}\ngroup by table_owner, table_name\nhaving max(blocks)/min(blocks) > {pred})', 
  'schema_name':'table_owner'}, 
 'GLOBAL_INDEX':{'sql':"\nselect count(*) COUNT\nfrom dba_indexes i, dba_tables t\nwhere i.partitioned = 'NO'\nand i.uniqueness <> 'UNIQUE'\nand t.partitioned = 'YES'\nand i.table_owner = t.owner\nand i.table_name = t.table_name\nand t.{schema_pred}", 
  'schema_name':'owner'}, 
 'SELECT_STAR':{'sql':"\nselect count(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(regexp_replace(translate(regexp_replace(sql_text,'--.*$',''),chr(10)||chr(11)||chr(13), ' '),'/\\*.*\\*/',''), 'select[[:space:]]+\\*', 'i')\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'WITH_HINT':{'sql':"\nselect\n    count(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand (regexp_like(sql_text, '--\\+') or regexp_like(translate(sql_text,chr(10)||chr(11)||chr(13), ' '),'/\\*\\+.*\\*/'))\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'SQL_PROFILE':{'sql':'\nselect\n    count(*) COUNT\nfrom gv$sql a\nwhere a.{inst_id_pred}\nand {schema_pred}\nand {sql_text_pred}\nand (SQL_PROFILE is not null or sql_plan_baseline is not null)', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'SKEW_COLUMN':{'sql':"select count(*) COUNT from\n(\nselect\n    OWNER,\n    TABLE_NAME,\n    COLUMN_NAME,\n\tendpoint_value\t\t\t\trow_value,\n\tround(RATIO_TO_REPORT(row_count) OVER (partition by owner, table_name, column_name) * 100) AS pct\nfrom (\n        select\n            h.OWNER,\n            h.TABLE_NAME,\n            h.COLUMN_NAME,\n            h.endpoint_value,\n            h.endpoint_number -\n            nvl(lag(endpoint_number,1) over (partition by h.owner, h.table_name, h.column_name\n                order by endpoint_number\n            ),0)\t\t\t\trow_count\n        from\n            dba_tab_histograms h, dba_tab_columns c\n        where\n        c.{schema_pred}\n    and   h.owner = c.owner\n    and    h.table_name = c.table_name\n    and    h.column_name = c.column_name\n    and    c.histogram != 'NONE'\n    )\n) group by OWNER, TABLE_NAME, COLUMN_NAME\nhaving max(pct) > {pred}", 
  'schema_name':'OWNER'}, 
 'WRONG_HISTOGRAM':{'sql':"select\n    count(*) COUNT\nfrom\n    dba_tab_columns\nwhere\n    {schema_pred}\nand num_distinct > 1\nand histogram != 'NONE'\nand num_buckets = 1", 
  'schema_name':'OWNER'}, 
 'NESTED_BLOCK':{'sql':'\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a, (\n        select distinct inst_id, sql_id, child_number\n        from\n                gv$sql_plan p\n        where\n        p.other_xml is not null and {inst_id_pred}\n        and (SELECT /*+ opt_param(\'parallel_execution_enabled\', \'false\') */\n                      count(*)\n                      FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), \'/*/outline_data/hint\'))) d\n                      where regexp_like(extractvalue(value(d), \'/hint\'), \'^OUTLINE\\(@"SEL\\$[[:digit:]]"\\)\')\n              ) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand {sql_text_pred}\nand a.{inst_id_pred}\nand {schema_pred}', 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'MANY_TABLE':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a, (\n        select distinct inst_id, sql_id, child_number\n        from\n                gv$sql_plan p\n        where\n        p.other_xml is not null and {inst_id_pred}\n        and (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */\n                count(*)\n                FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(p.other_xml), '/*/outline_data/hint'))) d\n                where regexp_like(extractvalue(value(d), '/hint'), '^(FULL|INDEX)')) > {pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand {sql_text_pred}\nand a.{inst_id_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'LEFT_WILDCARD':{'sql':"\nselect\n    count(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand regexp_like(translate(sql_text,chr(10)||chr(11)||chr(13), ' '),'like[[:space:]]+''%')\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'INSERT_VALUE':{'sql':"\nselect count(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(regexp_replace(translate(regexp_replace(sql_text,'--.*$',''),chr(10)||chr(11)||chr(13), ' '),'/\\*.*\\*/',''), 'insert[[:space:]]+into[^(]+values', 'i')\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'MANY_BINDS':{'sql':"\nselect\n  count(*) COUNT\nfrom gv$sqlarea a\nwhere\na.{inst_id_pred}\nand REGEXP_LIKE(sql_text, 'in[^(]+\\((:[[:alnum:]_]+,[[:space:]]*){{{pred}}}', 'i')\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'PARSING_SCHEMA_NAME'}, 
 'OBJECT_CREATED':{'sql':'\nselect\n    COUNT(*) COUNT\nfrom\n    dba_objects\nwhere {schema_pred}\nand sysdate - created < {pred}', 
  'schema_name':'owner'}, 
 'OBJECT_DDL':{'sql':'\nselect\n    COUNT(*) COUNT\nfrom\n    dba_objects\nwhere {schema_pred}\nand sysdate - last_ddl_time < {pred}\nand sysdate - created > {pred}', 
  'schema_name':'owner'}, 
 'JOIN_NULL':{'sql':"\nselect\n    count(*) COUNT\nfrom\n    sys.col_usage$ usage,\n    dba_objects obj,\n    dba_tab_cols cols\nwhere\n    obj.object_type = 'TABLE'\nand usage.EQUIJOIN_PREDS > {pred}\nand obj.{schema_pred}\nand cols.{schema_pred}\nand cols.nullable = 'Y'\nand num_nulls = 0\nand usage.OBJ# = obj.object_id\nand obj.owner = cols.owner\nand obj.object_name = cols.table_name\nand usage.INTCOL# = cols.column_id", 
  'schema_name':'owner'}, 
 'FOR_UPDATE':{'sql':"\nselect /*+ leading(b a) use_hash(a)*/\n    count(*) COUNT\nfrom gv$sql a,\n      ( select distinct inst_id, sql_id, child_number\n        from gv$sql_plan\n        where operation = 'FOR UPDATE' and {inst_id_pred}) b\nwhere\n    a.sql_id = b.sql_id\nand a.inst_id = b.inst_id\nand a.child_number = b.child_number\nand a.{inst_id_pred}\nand {sql_text_pred}\nand {schema_pred}", 
  'schema_name':'parsing_schema_name'}, 
 'CHAR_COL':{'sql':"\n        select COUNT(*) COUNT\n        from dba_tab_cols\n        where data_type in ('CHAR') and {schema_pred}\n        group by owner, table_name", 
  'schema_name':'owner'}}
# okay decompiling ./restful/hawkeye/sqlaudit/enum/oracle_problem_template_enum.pyc
